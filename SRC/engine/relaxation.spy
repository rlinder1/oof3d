# -*- python -*-

# Imports copied directly from cfiddlenodes.spy
from ooflib.common import cregisteredclass
from ooflib.common import debug
from ooflib.common.IO import parameter
from ooflib.common.IO import xmlmenudump
from ooflib.common.IO import reporter
from ooflib.engine import iterationmanager
from ooflib.SWIG.engine import cskeletonmodifier
from ooflib.SWIG.common import switchboard
from ooflib.SWIG.common import progress
from ooflib.engine.IO import skeletongroupparams
from ooflib.engine import bdycondition
from ooflib.SWIG.engine import field
from ooflib.SWIG.engine import masterelement
from ooflib.engine import materialmanager
from ooflib.SWIG.engine.property.elasticity.iso import iso
from ooflib.SWIG.engine.property.skeletonrelaxationrate \
import skeletonrelaxationrate
from ooflib.engine.IO import isocijkl
from ooflib.common.IO import reporter
from ooflib.SWIG.engine import equation
from ooflib.engine import profile
from ooflib.SWIG.common import threadstate
from ooflib.engine import fieldinit
from ooflib.engine.IO import meshmenu
from ooflib.engine import solvermode 
from ooflib.engine import staticstep 
from ooflib.engine import nonlinearsolver 
from ooflib.engine import matrixmethod 
from ooflib.SWIG.engine import preconditioner
from ooflib.engine import evolve
from ooflib.engine import propertyregistration
from ooflib.SWIG.engine import ooferror2
import ooflib.engine.mesh



#Sets the elasticity and skeleton relaxation rate properties
#for the secret material used in relaxation.
def _Relax_setProperties(self):
    
    threadno = threadstate.findThreadNumber()
    
    stiffnessPropReg = iso.IsotropicElasticity.named_copy(
            "__stiffness%d__" % threadno, secret=True)

    stiffnessPropReg.getParameter('cijkl').value = \
        isocijkl.IsotropicRank4TensorCij(c11=1.0, c12=0.5)

    relaxPropReg = skeletonrelaxationrate.SkeletonRelaxationRateTensor.\
            named_copy("__relaxationrate%d__" % threadno, secret=True) 
    self.materialName = 'boneMarrow'
    print "dummy material for relaxation has been created, relaxation.spy"
    materialmanager.materialmanager.add_secret(self.materialName)
    self.stiffness = stiffnessPropReg()
    
    materialmanager.materialmanager.add_prop(self.materialName,
                                             self.stiffness.name())
    
    #does anything need to be switched around?
    relaxPropReg.getParameter("alpha").value = self.getAlpha()
    relaxPropReg.getParameter("gamma").value = self.getGamma()
    self.skelRelRate = relaxPropReg()

    materialmanager.materialmanager.add_prop(self.materialName,
                                             self.skelRelRate.name())

RelaxPtr.setProperties = _Relax_setProperties



#Returns the material we are using
def _Relax_material(self):
    return materialmanager.getMaterial(self.materialName)
RelaxPtr.material = _Relax_material



#Checks that skeleton is legal, we have more iterations,
#and that the solver has not failed to converge
def _Relax_goodToGo(self, skeleton):
    skeleton.checkIllegality()
    print "inside goodtogo, r.spy, printing skeleton status:"
    print skeleton;
    #This is a temporary workaround
    if (skeleton.getIllegalCount() > 0):
        self.count = self.iterations
        return False
            
    return (not skeleton.illegal()
            and self.count < self.iterations
            and self.solverConverged)
RelaxPtr.goodToGo = _Relax_goodToGo



#Increments iteration counter
def _Relax_updateIteration(self, prog):
    self.count += 1
RelaxPtr.updateIteration = _Relax_updateIteration




#Creates a mesh with the default subproblem
def _Relax_create_mesh(self, context):
    edict = {}
    edict['Tetrahedron'] = masterelement.getMasterElementByName('TET4_4')
    edict['Triangle'] = masterelement.getMasterElementByName('T3_3')
    #added above line because femesh call was giving issues
    skel = context.getObject()
    self.meshName = context.path() + ":__internal_mesh__"
    
    femesh = skel.femesh(edict, self.material())
    
    meshcontext = ooflib.engine.mesh.meshes.add(
        self.meshName, femesh,
        parent=context,
        skeleton=skel, elementdict=edict)
    
    meshcontext.createDefaultSubProblem()
    
    return meshcontext

RelaxPtr.create_mesh =  _Relax_create_mesh

def _Relax_define_fields(self, meshctxt):
    
    femesh = meshctxt.femesh()
    subp = meshctxt.get_default_subproblem().getObject()
    displacement = field.getField('Displacement')
    subp.define_field(displacement)
    subp.activate_field(displacement)
RelaxPtr.define_fields = _Relax_define_fields


#Activates force-balance equation for the default subproblem
def _Relax_activate_equations(self, meshctxt):
    
    meshctxt.get_default_subproblem().getObject().activate_equation(
        equation.getEquation('Force_Balance'))
RelaxPtr.activate_equations = _Relax_activate_equations



#Sets conditions along all six boundaries to
#prevent boundary nodes from moving
def _Relax_set_boundary_conditions(self, mesh):
    
    displacement = field.getField('Displacement')
    self.leftBoundaryCondition = \
        bdycondition.DirichletBC(displacement,
                                 'x',
                                 equation.getEquation('Force_Balance'),
                                 'x',
                                 profile.ConstantProfile(0),
                                 'Xmin'
                                 )
    self.leftBoundaryCondition.add_to_mesh('left', mesh.path())

    self.rightBoundaryCondition = \
        bdycondition.DirichletBC(displacement,
                                 'x',
                                 equation.getEquation('Force_Balance'),
                                 'x',
                                 profile.ConstantProfile(0),
                                 'Xmax'
                                 )
    self.rightBoundaryCondition.add_to_mesh('right', mesh.path())

    self.topBoundaryCondition = \
        bdycondition.DirichletBC(displacement,
                                 'y',
                                 equation.getEquation('Force_Balance'),
                                 'y',
                                 profile.ConstantProfile(0),
                                 'Ymax'
                                 )
    self.topBoundaryCondition.add_to_mesh('top', mesh.path())

    self.bottomBoundaryCondition = \
        bdycondition.DirichletBC(displacement,
                                 'y',
                                 equation.getEquation('Force_Balance'),
                                 'y',
                                 profile.ConstantProfile(0),
                                 'Ymin'
                                 )
    self.bottomBoundaryCondition.add_to_mesh('bottom', mesh.path())

    self.frontBoundaryCondition = \
        bdycondition.DirichletBC(displacement,
                                 'z',
                                 equation.getEquation('Force_Balance'),
                                 'z',
                                 profile.ConstantProfile(0),
                                 'Zmax'
                                 )
    self.frontBoundaryCondition.add_to_mesh('front', mesh.path())

    self.backBoundaryCondition = \
        bdycondition.DirichletBC(displacement,
                                 'z',
                                 equation.getEquation('Force_Balance'),
                                 'z',
                                 profile.ConstantProfile(0),
                                 'Zmin'
                                 )
    self.backBoundaryCondition.add_to_mesh('back', mesh.path())

RelaxPtr.set_boundary_conditions = _Relax_set_boundary_conditions



def _Relax_update_node_positions(self, skeleton, mesh):
    
    skeleton.incrementTimestamp()
    femesh = mesh.getObject()
    
    self.updateNodePositionsC(skeleton, femesh)
    
RelaxPtr.update_node_positions = _Relax_update_node_positions

# def _Relax_apply(self, oldskeleton, context):
#     prog = progress.getProgress("Relax", progress.DEFINITE)
#     prog.setMessage("Preparing to relax...")
#     return oldskeleton.deputyCopy()
# RelaxPtr.apply = _Relax_apply

    
#Not clear if this function does anything...
def _Relax_initialize_fields(self, mesh):
    print "initialized fields" #doesn't show up (yet?)
    initializer = fieldinit.ConstTwoVectorFieldInit(cx=0.0, cy=0.0, cz=0.0)
    meshmenu.initField(self, self.meshName, field.getField('Displacement'),
                       initializer)
    meshmenu.applyFieldInits(self, self.meshName)

RelaxPtr.initialize_fields = _Relax_initialize_fields




#Handles the overall relaxation process
#(This function is kind of like main for relaxation.*)
def _Relax_postProcess(self, context):
    #could put something here to stop execution if user-given values are bad,
    #if we can't figure out how to gray out OK in that case
    self.setProperties()
    prog = progress.getProgress("Relax", progress.DEFINITE)
    skeleton = context.getObject()
    print "printing skeleton at beginning of post process"
    print skeleton
    
    before = skeleton.energyTotal(self.getAlpha())
    
    self.count = 0
    self.iterations = self.getIterations()
    self.solverConverged = True

    try:
        print "right before while loop in pp, printing skeleton"
        print skeleton
        while self.goodToGo(skeleton) and not prog.stopped():
            print "begin iteration ", self.count, "in relaxation.spy"
            mesh = self.create_mesh(context)
            self.define_fields(mesh)
            #self.initialize_fields(mesh)
            self.activate_equations(mesh)
            mesh.changed("Relaxing") #necessary? what does it do?
            self.set_boundary_conditions(mesh)

            self.coreProcess(mesh, mesh.get_default_subproblem()) 
            if prog.stopped():
                print "progress stopped, relaxation.spy "
                break


            print "after core process, printing skeleton and context.getObject()"
            print skeleton
            print context.getObject()
            
            print "checking illegality after core process"
            skeleton.checkIllegality()
            context.getObject().checkIllegality()

            print "printing again after checking legality"
            print skeleton
            print context.getObject()
            try:
                print "before updating positions, what is homogeneity?"
                print skeleton.getHomogeneityIndex()
            except:
                print "getting homog index caused exception before updating nodes"
            context.begin_writing()
            try:
                self.update_node_positions(skeleton, mesh)
            finally:
                context.end_writing()


            print "after updating positions, printing skeleton and context.getObject()"
            print skeleton
            
            print context.getObject()
            

                
            try:
                print "after updating positions, what is homogeneity?"
                print skeleton.getHomogeneityIndex()
            except:
                print "getting homog index caused exception after updating nodes"
            print "skeleton status immediately after updating nodes"
            print skeleton
        
            mesh.lockAndDelete()
            print "immediately after locking and deleting mesh, r.spy pp"
            #This is the line that calls skeletonPage.update
            try:
                print "begin try change notification, r.spy, pp"
                switchboard.notify("Skeleton changed", context.path())
                print "end try change notification, r.spy, pp"
            except:
                print "notification of change caused an exception, r.spy pp"
            print "immediately after notifying switchboard of skel change, r.spy pp"
            switchboard.notify("redraw")
            print "immediately after notifying switchboard of redraw, r.spy pp"
            

            #temporary workaround
            try:
                print skeleton.getHomogeneityIndex(), "just printed homog index"
            except ooferror2.ErrHomogeneityNotCalculable:
                print "caught exception in relaxation.spy, near end of post process"
                self.count = self.iterations

            
            print "printing skeleton info at end of while loop" 
            print skeleton
            print "skeleton.getIllegalCount ", skeleton.getIllegalCount() 
            if skeleton.getIllegalCount():
                self.count = self.iterations
            else:
                self.updateIteration(prog)
                prog.setFraction(1.0 * self.count/ self.iterations)
                prog.setMessage("%d/%d iterations" % (self.count, self.iterations))


            print "messing around with skeleton illegality at end of postprocess while loop"
            print "printing skeleton"
            print skeleton
            print "checking illegality"
            skeleton.checkIllegality()
            print "printing skeleton"
            print skeleton
            print "setting illegal"
            skeleton.setIllegal()
            print "printing skeleton"
            print skeleton
            print "checking illegality again"
            skeleton.checkIllegality()
            print "printing skeleton"
            print skeleton
            print "setting legal"
            skeleton.setLegal()
            print "printing skeleton"
            print skeleton
            print "checking illegality"
            skeleton.checkIllegality()
            print "printing skeleton one last time"
            print skeleton
    

        #prog.finish()
        print "is skeleton illegal at end of post process?"
        skeleton.checkIllegality()
        print skeleton.illegal()
        print "printing skeleton at end of postprocess"
        print skeleton


        


        
        try:
            after = skeleton.energyTotal(self.getAlpha())
        except:
            print "calculating after caused a problem, r.spy, pp"
            after = before
        if before:
            rate = 100.0*(before - after)/before
        else:
            rate = 0.0
        diffE = after - before
        reporter.report("Relaxation complete: deltaE = %10.4e (%6.3f%%)"
                    % (diffE, rate))

    finally:
        print "reached finally block for iteration", self.count, "in relaxation.spy"
        prog.finish()
        #Once the issue with detecting illegal elements and graying out the
        #OK button is correctly fixed, the following block doesn't need 'try'
        #It would only come up if they put 0 iterations, which hopefully we can
        #stop them from doing anyway
        try:
            del self.topBoundaryCondition
            del self.bottomBoundaryCondition
            del self.leftBoundaryCondition
            del self.rightBoundaryCondition
            del self.backBoundaryCondition
            del self.frontBoundaryCondition
        except:
            print "tried to delete non-existent boundary cond, relaxation.spy"
    
        materialmanager.materialmanager.delete_prop(self.stiffness.name())
        materialmanager.materialmanager.delete_prop(self.skelRelRate.name())
        #propertyregistration.AllProperties.delete(self.stiffness.name())
        #propertyregistration.AllProperties.delete(self.skelRelRate.name())
        print "dummy material for relax has been deleted, relaxation.spy"
        materialmanager.materialmanager.delete_secret(self.materialName)
    
    
RelaxPtr.postProcess = _Relax_postProcess

def _Relax_coreProcess(self, meshctxt, subp):
    
    subp.solver_mode = solvermode.AdvancedSolverMode(
        time_stepper=staticstep.StaticDriver(),
        nonlinear_solver=nonlinearsolver.NoNonlinearSolver(),
        symmetric_solver=matrixmethod.ConjugateGradient(
            preconditioner.ILUPreconditioner(),
            1.e-5,          # tolerance
            1000            # max_iterations
            ),
        asymmetric_solver=matrixmethod.BiConjugateGradient(
            preconditioner.ILUPreconditioner(),
            1.e-5,          # tolerance
            1000            # max_iterations
            )
        )

    meshctxt.begin_writing()
    try:
        
        try:
            evolve.evolve(meshctxt, 0.0)
        except:
            # TODO: Be more explicit about what exceptions
            # should be handled here, to distinguish actual
            # convergence failures from programming errors.
            print "except block in core process, relaxation.spy"
            self.solverConverged = False
        else:
            self.solverConverged = True
    finally:
        meshctxt.end_writing()
    
    
    
RelaxPtr.coreProcess = _Relax_coreProcess


#Not sure if needed
def _Relax___repr__(self):
    return "Relaxation"

RelaxPtr.repr = _Relax___repr__


#Not sure if needed
def _Relax_get_progressbar_type(self):
    return "continuous"

RelaxPtr.getProgressbarType = _Relax_get_progressbar_type

#Class registration
relaxReg = cregisteredclass.Registration(
    'Relax',
    CSkeletonModifierBasePtr,
    Relax,
    ordering=-1, #change this later, probably
    params = [
        cskeletonmodifier.alphaParameter,
        parameter.FloatParameter(name = 'gamma', value = 0.5,
                                 tip = 'Node mobility'),
        parameter.IntParameter('iterations', value = 1, tip = 'number of steps')
        ],
    tip='Improve a skeleton by solving a finite element system where the properties are functions of the underlying homogeneity and shape',
    discussion=xmlmenudump.loadFile('DISCUSSIONS/engine/reg/relax.xml')
    )



#This is what it seems like it should be based off of cfiddlenodes.spy,
#but it gives an error
# def _Relax___init__(self, alpha, gamma, iterations,
#                     iteration, oldinit=Relax.__init__):
#     oldinit(self, alpha, gamma, iterations)
#     self._keepargs = self._keepargs + [iteration]
#     self.iteration = iteration
#     self.intro = "Preparing to relax skeleton...   "
#     self.header = "Relaxing skeleton: "
#     self.outro = "Relaxing done: "
# Relax.__init__ = _Relax___init__

#Works ok... but will I need iteration later?
#What does this do?
def _Relax___init__(self, alpha, gamma, iterations, oldinit=Relax.__init__):
    oldinit(self, alpha, gamma, iterations)
    self.intro="Preparing to relax skeleton..."
    self.header = "Relaxing skeleton: "
    self.outro = "Relaxing done: "
Relax.__init__ = _Relax___init__
